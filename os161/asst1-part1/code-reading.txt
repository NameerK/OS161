1. When a thread exits the thread number variable is lowered by 1 and the unecessary memory is de-allocated. The address spaces used by the thread are also removed. When a thread sleeps it goes into a suspended state and gets a sleep address to keep track of it, the thread then waits to be awoken when it is its turn to run on the CPU.
2. In thread.c the functions mi_switch and md_switch handle context switching
3. When a thread is in the S_RUN state then it is being executed on the CPU. S_READY means that the thread is ready to run on the CPU but hasn't started running yet. S_SLEEP means that the thread has stopped running on the CPU and its currently not executing. S_ZOMB means that the thread has finished running completely and is waiting to be reaped by the parent process
4. When you turn interrupts off it means that the thread will ignore any interrupts and will run through all of its code including any critical sections without being interrupted. Turning off interrupts is accomplished by using spl functions. It is important to turn off interrupts in the thread subsytem code so that the threads can complete critical sections of their code without interrupts.
5. When a thread wakes up another thread a call to thread_wakeup is made using the sleep address of the the sleeping thread, that thread then goes to the ready state and waits for the scheduler to give it CPU time to run. A sleeping thread gets to run when another thread calls thread_wakeup with its sleep address
6. Scheduler() chooses the next thread to run
7. It picks the thread at the head of the queue of runnable threads, if the queue is empty it will wait until there is something in the queue
8. The hardware timer has a time quantum for how long a process gets to run on the CPU. The hardware independent function called on a timer interrupt is hardclock()
9. thread_sleep() is used on threads that are waiting for a semaphore and thread_wakeup() is used on threads when the semaphore is available to be claimed. The argument passed to thread_sleep() is the sleep address of the thread that is being put to sleep or awoken, it is used to keep track of sleeping threads so they don't sleep forever.
10. lock_do_i_hold() checks if the current thread holds the lock but lock_get_holder returns the thread that currently has the lock which creates a problem since it could give itself the lock effectively stealing it from the other thread which is bad because then threads could access critical sections improperly.